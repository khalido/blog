<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <!--temp stylesheet, customize my own one later.
        https://github.com/kognise/water.css-->
        
        
        <link rel="stylesheet" href="https://fonts.xz.style/serve/inter.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@exampledev/new.css@1.1.3/new.min.css">

        <link rel="stylesheet" type="text/css" href="/codestyles.css">
        
        

        <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/styles/default.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.4.0/highlight.min.js"></script>

        <title>quicksort</title>
    </head>

    <body>
 
        <header>
            <a href="/">"khalido.org"</a> <br>
            "some subheader text."
        </header>

<article>
        <h1>quicksort</h1>

    <div class="meta">
        posted <time>2018-08-10</time>, updated <time>2021-05-24</time><br>
        tagged: 
        <a href="/algorithims">algorithims</a>
        
        <p>
            <a href="https://github.com/khalido/blog/blob/master/notebooks/quicksort.ipynb">github</a>, 
            <a href="https://colab.research.google.com/github/khalido/blog/blob/master/notebooks/quicksort.ipynb">
                colab
            </a>
        
        </p>
    
    </div>
    
    <details open>
        <summary>Table of contents.</summary>
        <div class="toc">
<ul>
<li><a href="#using-a-random-pivot">using a random pivot</a></li>
<li><a href="#visualizing-quicksort">visualizing quicksort</a></li>
<li><a href="#use-animations-to-visualize-quicksort">use animations to visualize quicksort</a></li>
</ul>
</div>

    </details>
    
    <hr>
    
    <p>sort an array by choosing a point in the array, called the pivot point, then creating two smaller arrays:
Keep in mind an array of size one is already sorted, so no need to sort that.</p>
<ul>
<li>choose a point, called the pivot point</li>
<li>make an array containing everything smaller or equal to the pivot</li>
<li>second array containing everything bigger than the pivot</li>
<li>so the answer is just quicksort(smaller_array) + pivot + quicksort(bigger_array)</li>
</ul>
<p>first to generate some random data:</p>
<pre><code class="language-python">import random
import numpy as np
random_data = [random.randint(0,100) for i in range(10)]
random_data[:10]
</code></pre>
<pre><code>[45, 66, 96, 78, 5, 50, 80, 78, 36, 4]
</code></pre>
<pre><code class="language-python">def quicksort(data):
    if len(data) &lt; 2:
        return data
    else:   
        pivot = data[0]
        less = [i for i in data[1:] if i &lt;= pivot]
        more = [i for i in data[1:] if i &gt; pivot]
        return quicksort(less) + [pivot] + quicksort(more)

quicksort(random_data)
</code></pre>
<pre><code>[4, 5, 36, 45, 50, 66, 78, 78, 80, 96]
</code></pre>
<h2 id="using-a-random-pivot">using a random pivot</h2>
<p>Quicksort works faster when using a random pivot</p>
<pre><code class="language-python">def quicksort2(data):
    import random
    if len(data) &lt; 2:
        return data
    else:
        p_idx = random.randrange(0,len(data)-1)
        pivot = data[p_idx]

        less = [i for i in data[:p_idx] if i &lt;= pivot] + [i for i in data[p_idx+1:] if i &lt;= pivot]
        more = [i for i in data[:p_idx] if i &gt; pivot] + [i for i in data[p_idx+1:] if i &gt; pivot]
        return quicksort2(less) + [pivot] + quicksort2(more)

quicksort2(random_data)
</code></pre>
<pre><code>[4, 5, 36, 45, 50, 66, 78, 78, 80, 96]
</code></pre>
<p>some tests to make sure the algos are working correctly</p>
<pre><code class="language-python">assert len(random_data) == len(quicksort(random_data))
assert quicksort(random_data) == quicksort2(random_data) == sorted(random_data)

a = [i for i in range(10)]
random.shuffle(a)
assert [i for i in range(10)] == quicksort(a) == quicksort2(a)
</code></pre>
<pre><code class="language-python">%%timeit
quicksort(random_data)
</code></pre>
<pre><code>8.86 µs ± 265 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</code></pre>
<pre><code class="language-python">%%timeit
quicksort2(random_data)
</code></pre>
<pre><code>23.8 µs ± 851 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
</code></pre>
<h2 id="visualizing-quicksort">visualizing quicksort</h2>
<p>there are many better visuals on the web, heres my stab:</p>
<p>I modified the quicksort function above so it only does one sort step and returns the list:</p>
<pre><code class="language-python">import matplotlib.pyplot as plt
import seaborn as sns
from IPython.display import HTML
</code></pre>
<pre><code class="language-python">def quicksort_onestep(data):
    import random
    if len(data) &lt; 2:
        return data
    else:
        p_idx = random.randrange(0,len(data)-1)
        pivot = data[p_idx]

        less = [i for i in data[:p_idx] if i &lt;= pivot] + [i for i in data[p_idx+1:] if i &lt;= pivot]
        more = [i for i in data[:p_idx] if i &gt; pivot] + [i for i in data[p_idx+1:] if i &gt; pivot]
        return less + [pivot] + more

quicksort_onestep(random_data)
</code></pre>
<pre><code>[45, 66, 5, 50, 78, 36, 4, 78, 96, 80]
</code></pre>
<p>Here I add the list after each sort step to an array <code>qs_steps</code>.</p>
<pre><code class="language-python">def compare_lists(a, b):
    &quot;returns True if two lists contain the same element at each index, false otherwise&quot;
    assert len(a) == len(b)
    for pair in zip(a, b):
        if pair[0] != pair[1]:
            return False
    return True

random_data = [random.randint(0,100) for i in range(100)]
sorted_data = quicksort2(random_data)
plt.plot(random_data, label=&quot;initial data&quot;, lw=1.5, ls=&quot;dashed&quot;)

qs_steps = []

# first quicksort step
d = quicksort_onestep(random_data)
qs_steps.append(d)
plt.plot(d, alpha=0.5, lw=0.8, label=&quot;first pass&quot;)

#rest of quicksort steps
q_pass = 1
while not (compare_lists(sorted_data, d)):
    q_pass += 1
    d = quicksort_onestep(d)
    qs_steps.append(d)
    if compare_lists(d, sorted_data):
        plt.plot(sorted_data, c=&quot;r&quot;, ls=&quot;dashed&quot;, lw=2.5, label=&quot;sorted&quot;, alpha = 0.9)
    else:
        plt.plot(d, alpha=0.7, lw=0.8)

print(f&quot;it took {len(qs_steps)} steps to sort {len(random_data)} items&quot;)
# make plot bigger
plt.legend();
</code></pre>
<pre><code>it took 184 steps to sort 100 items
</code></pre>
<p><img alt="svg" src="quicksort_files/quicksort_14_1.svg" /></p>
<h2 id="use-animations-to-visualize-quicksort">use animations to visualize quicksort</h2>
<p><code>qs_steps</code> is a array containing each step in the quicksort algorithim.</p>
<p>Using <a href="https://matplotlib.org/examples/animation/index.html">matplotlib.animation</a> to animate this.</p>
<p>Github doesn't render videos for some reason, so see this <a href="http://nbviewer.jupyter.org/github/khalido/algorithims/blob/master/quicksort.ipynb">notebook at nbviewer</a> for the pretty animations.</p>
<pre><code class="language-python"># to display animations inline
#%matplotlib nbagg  
import matplotlib.animation as animation
from IPython.display import HTML, display
</code></pre>
<pre><code class="language-python"># the data
x = [i for i in range(len(qs_steps[0]))]
y = qs_steps

# the figure
fig, ax = plt.subplots()
fig.set_size_inches(8,6)
ax.set_title(&quot;Quick Sort steps&quot;)
ax.set_xlabel('X')
ax.set_ylabel('Y')

# this displays the data to be sorted as a scatter plot
original_line = ax.scatter(x,y[0], alpha = 0.2, label = &quot;original data&quot;)
# the final sorted line.
sorted_line = ax.plot(x,y[-1], lw=2, alpha = 0.7, label=&quot;sorted&quot;)

# this displays the data being sorted in a scatter plot
scatterplot = ax.scatter(x,y[0], label=&quot;sorting&quot;)

def animate(i):
    scatterplot.set_offsets(np.c_[x,y[i]])

ani = animation.FuncAnimation(fig, animate, 
                frames=len(y), interval=150, repeat=False) 

print(f&quot;it took {len(qs_steps)-1} steps to sort {len(qs_steps[0])} items&quot;)
plt.legend()
#ani.save(&quot;quicksort_animate.mp4&quot;)
plt.show();
</code></pre>
<pre><code>it took 183 steps to sort 100 items
</code></pre>
<p><img alt="svg" src="quicksort_files/quicksort_17_1.svg" /></p>
<p>Another animation, this time using lines instead of a scatter plot.</p>
<pre><code class="language-python">x = [i for i in range(len(qs_steps[0]))]
y = qs_steps

fig1, ax1 = plt.subplots()

# why the heck does line need a comma after it?
line, = ax1.plot(x,y[0], lw=3, alpha=0.8, label=&quot;sorting&quot;)
line2, = ax1.plot(x,y[0], lw=2, alpha = 0.1, label = &quot;one step before&quot;)
line3 = ax1.plot(x,y[0], lw=0.8, alpha = 0.4, label = &quot;original data&quot;)
line3 = ax1.plot(x,y[-1], lw=1, alpha = 0.6, label=&quot;sorted&quot;)

fig1.set_size_inches(8,6)
ax1.set_title(&quot;Quick Sort steps&quot;)
ax1.set_xlabel('X')
ax1.set_ylabel('Y')

def animate(i):
    line.set_ydata(y[i])  # update the data
    if i &gt; 1:
        line2.set_ydata(y[i-1])

ani2 = animation.FuncAnimation(fig1, animate, 
                frames=len(y), interval=120, repeat=False) 

print(f&quot;it took {len(qs_steps)-1} steps to sort {len(qs_steps[0])} items&quot;)
plt.legend();
#ani2.save(&quot;quicksort_animate1.mp4&quot;)
</code></pre>
<pre><code>it took 183 steps to sort 100 items
</code></pre>
<p><img alt="svg" src="quicksort_files/quicksort_19_1.svg" /></p>
<pre><code class="language-python">
</code></pre>
</article>

<script>hljs.initHighlightingOnLoad();</script>


<hr>
<footer>
    This is a footer. One day some footery text will go here. 
</footer>



</body>

</html>